---
title: السنانير النموذجية
description: افتح النماذج برمجيًا عبر السنانير
---

# السنانير النموذجية

## افتح النماذج برمجيًا عبر السنانير

يتم توفير السنانير التالية للسماح بالفتح البرمجي للنماذج في أي مكان في تطبيقك.

- `useConnectModal`
- `useAccountModal`
- `useChainModal`

كل واحد من هذه السنانير يرجع كائن بوظيفة لفتح النموذج الخاص به. لاحظ أن الوظائف التي تُرجع ستكون غير معرفة إذا لم يكن تطبيقك في الحالة المطلوبة لفتح النموذج.

```tsx
import {
  useConnectModal,
  useAccountModal,
  useChainModal,
} from '@rainbow-me/rainbowkit';

export const YourApp = () => {
  const { openConnectModal } = useConnectModal();
  const { openAccountModal } = useAccountModal();
  const { openChainModal } = useChainModal();

  return (
    <>
      {openConnectModal && (
        <button onClick={openConnectModal} type="button">
          Open Connect Modal
        </button>
      )}

      {openAccountModal && (
        <button onClick={openAccountModal} type="button">
          Open Account Modal
        </button>
      )}

      {openChainModal && (
        <button onClick={openChainModal} type="button">
          Open Chain Modal
        </button>
      )}
    </>
  );
};
```

كل سنارة أيضًا تُرجع قيمة منطقية لحالة النموذج. عادة ما يُوصى بأن تعتمد فقط على سنانير Wagmi (كـ `useAccount`) للتفاعل مع حالة اتصال محفظة المستخدم بشكل مباشر، بدلًا من الاعتماد على حالة نموذج الاتصال.

```tsx
const { connectModalOpen } = useConnectModal();
const { accountModalOpen } = useAccountModal();
const { chainModalOpen } = useChainModal();
```

يتم تصميم RainbowKit ليكون غير مقتحم ومتجاوب، لذا يجب على التطبيقات اللامركزية دائمًا عرض واجهة للمستخدمين سواء قاموا بتوصيل محافظهم أم لا. يمكن للمستخدم توصيل أو فصل محافظته مباشرة من MetaMask، لذا يجب أن يكون dApp متجاوب مع حالة الاتصال الأساسية مباشرة.

يجب على التطبيقات اللامركزية التي تعتمد على آليات مثل تسجيل الدخول باستخدام Ethereum للتحقق من المستخدم أن تعتمد بدلًا من ذلك على [التوثيق](/docs/authentication).
